lima
====
A C-family programming language.
A highly expressive C-family general purpose programming language that frees the programmer from hand-written optimizations by being built around DSLs and modular optimizers.

## AST Format

##### Value Nodes:

**`["rawExpression", expressionString, metaData]`** - Represents a block of code that may contain one or more actual expressions. `metaData` contains an object with an `index` representing the index in the source code the rawExpression starts at.

**`["superExpression", parts]`** - Represents a partially resolved rawExpression. The `parts` is a list of values nodes and operator nodes. Value nodes must be separated by one or more special operator nodes. Because it may contain rawExpressions, it may represent multiple actual expressions.

**`["object", parts]`** - Represents an object literal. The `parts` is a list of value nodes and certain special nodes specific to `"object"` defined below.
* **`["static", statements]`** - A list of static statements to be run in the object scope as built at the point it appears. This may only be contained inside `parts` at the top-level.

**`["var", variableName]`**   Represents a variable name.

**`["string", primitiveString]`** - Represents a string literal.

**`["number", numerator, denominator]`** - Represents a number literal.

**`["macro", macroExpression, macroAst]`** - Represents a macro call. `macroExpression` is the expression that resolves to a macro, and `macroAst` is a node generated by the resolved macro. The `macroAst` can contain nodes with any custom name including special nodes with the name `"lima"` described below.
* **`["lima", limaNode]`** - `limaNode` must resolve to a valid lima AST. This can be used by things like syntax highlighters to properly highlight lima code that appears inside macros. A tool like a syntax highlighter can traverse the entire `macroAst` looking for `"lima"` nodes and parse them as if the macro didn't exist. This might not be quite what you want in cases where the macro creates a new scope or does other things that invalidate normal analysis, but in those cases, tools specific to the macro can be used to correctly analyze "lima"-typed sub-nodes of a macro.

##### Operator Nodes:

**`["binaryOperator", operator]`** - Must come after a value, `postfixOperator`, or `bracketOperator` node and before a value or `prefixOperator` node.

**`["prefixOperator", operator]`** - Must come before a value node or `bracketOperator` node.

**`["postfixOperator", operator]`** - Must come after a value node or `bracketOperator` node.

**`["openBracketOperator", operator]`** - Must come after a value node.

**`["closeBracketOperator", operator]`** - Must come after a value node.

##### Core Macro AST formats:

**`["macro", "const", ["lima", statements]]`** - Represents a `const` statement or block. The `statements` are the statements where declared variables will be marked as `const`.

**`["macro", "if", blocks]`** - Represents an `if` block. The `blocks` node contains a list of nodes of one of the following forms:
* **`["condition", conditionExpression, ["lima", statements]]`** - Represents a condition block.
* **`["else", ["lima", statements]]`** - Represents an else block.

**`["macro", "while", ["lima", conditionStatement], ["lima", endStatements], ["lima",mainStatements],["lima",elseStatements]]`** - Represents a `while` block.

**`["macro", "throw", ["lima", statement]]`** - Represents a `throw` command.

**`["macro", "try", ["lima", primaryStatements], ["lima", handlingStatements], ["lima", finallyStatements]]`** - Represents a `try` block.

**`["macro", "atry", ["lima", primaryStatements], ["lima", handlingStatements]]`** - Represents an `atry` block.

**`["macro", "rawthread", ["lima", statements]]`** - Represents a `rawthread` block.

**`["macro", "atomic", handleName, blocks]`** - Represents an `atomic` block where `handleName` is the name of the atomic block's handle object. Each node in `blocks` has the following form:
* **`["block", blockName, ["lima", statements]]`** - Where `blockName` is the name of the atomic block for use with the `atomicHandle`'s methods.

**`["macro", "future", ["lima", statements]]`** - Represents a `future` block.

**`["macro", "jump", ["lima", statement]]`** - Represents a `jump` command.

**`["macro", "assert", ["lima", conditionStatement], ["lima", probabilityStatement]]`** - Represents an `assert` command.

**`["macro", "optimize", ["names", cpuTime, memory, power], ["lima", metricStatement], ["lima", mainStatements]]`** - Represents an `optimize` command.

